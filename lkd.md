##### 1，内核开发的特点

- 无 libc 库亦或无标准头文件，内核实现了大多数常用的 C 库函数
- GNU C : 内联函数，内联汇编，分支声明 (likely)
- 没有内存保护机制
- 不要轻易在内核中使用浮点数
- 容积小而固定的栈，在 X86 上，32位 8KB，64位 16KB
- 同步和并发

##### 2，linux 进程

- task_struct 由 slab 分配器分配，以达到内存复用和缓存着色的目的。缓存着色 : 如果没有 color, task_struct 在内存中对于页的偏移量很可能相同则其 cache_line 索引也相同，对于 x86 这种 2 way cache 的结构，即使 cache size 很大，也一样效率低下。color则将不同slab中的同样的数据结构的地址进行一个偏移，因此这些数据结构的cache line索引就错开了，从而能更好的利用cache 。**着色即为添加偏移**
- PID 的最大默认值是 32768 (short int 短整型的最大值)，它是系统中允许同时存在的进程的最大数目
- **TASK_RUNNING, TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE, TASK_TRACED, TASK_STOPPED**
- 进程家族树，每个 task_struct 都保存着一个指向父进程 task_struct 的叫做 parent 的指针，还包含一个称为 children 的子进程链表
- 写时复制 : 避免了调用 fork 后立刻调用 exec 导致复制的父进程的资源都浪费了
- 内核线程和普通进程间的区别在于内核线程没有独立的地址空间 (实际上指向地址空间的 mm 指针被设置为 NULL) 。它们只在内核空间中运行，从来不切换到用户空间中去。所有内核线程的父线程都是 kthreadd 线程
- 父进程先于子进程退出就会产生孤儿进程，孤儿进程退出就会产生僵死进程，所以 init 进程会收养所有孤儿进程，孤儿进程会先寻找组内进程找不到才会找 init 进程
- 任何实时进程的优先级都高于普通的进程

##### 3，slab 内存分配器

- 为了弥补内存管理粒度太大的不足，可以解决部分内存碎片的问题
- 核心思想是使用对象的概念来管理内存 (这里的对象指具有相同的数据结构和大小的内存单元)
- slab 把不同的对象划分为所谓的高速缓存组，其中每个高速缓存组都存放不同类型对象，每种对象类型对应着一种高速缓存，每种高速缓存包含多个 slab
- 每个 slab 处于三种状态之一 : 满、部分满、空

##### 4，为什么有些进程 CTRL+C kill 不掉 : 因为它不接受信号

- 处于 **TASK_UNINTERRUPTIBLE** 状态，不接受信号

- 僵死程序，已释放所有资源，等待父进程确认，不接受信号
- 处于内核态，只有处于用户态才会被 kill 杀死，忽略所有信号

##### 5，linux 调度算法

- linux 调度器是以模块化的方式提供的，这种模块化的结构被称为调度器类

- O(1) : 进程多时比 CFS 有优势

- CFS : 针对普通进程的调度器，在Linux中称位SCHED_NORMAL，在POSIX中称为SCHED_OTHER

  - 选择运行时间最短的进程运行，选择具有最小 vruntime 的进程运行
  - 选择 CFS 为完美多任务中的无限小调度周期的近似值设置为 20ms，把所有进程调度一遍的时间
  - CFS 每个进程获得时间片的底线 1ms

  - 时间记账 vruntime，新进程的初始 vruntime 值就以它所在运行队列的 min_vruntime 为基础来设置。在休眠进程被唤醒时重新设置vruntime值，以min_vruntime值为基础，给予一定的补偿。进程从一个CPU的运行队列中出来 (dequeue_entity) 的时候，它的vruntime要减去队列的min_vruntime值，而当进程加入另一个CPU的运行队列 ( enqueue_entiry) 时，它的vruntime要加上该队列的min_vruntime值
  - 进程选择 rbtree 最左叶子节点 缓存在 rb_leftmost
  - 调度器入口 schedule()
  - 睡眠和唤醒 : 休眠的进程被放到等待队列
  - 用户抢占 : 内核返回用户空间时，如果need_sched被设置，会导致用户抢占
  - 内核抢占 : 中断上下文到内核，允许抢占时

- rt : 实时调度器 SCHED_FIFO，SCHED_RR

##### 6，系统调用

- 系统调用在出现错误的时候 C 库会把错误码写入 errno 全局变量。通过 perror() 库函数，可以把该变量翻译成用户可以理解的错误字符串
- 系统调用号，内核记录了系统调用表中的所有已注册过的系统调用的列表
- **系统调用是通过软中断实现的**，在x86系统上预定义的软中断的中断号是128号，用 int $0x80 指令触发该中断，并执行 128 号异常处理程序，而该程序正是系统调用处理程序，名叫 system_call()。在调用 int $0x80 前需要把系统调用号放入 eax 以便系统知道是那个系统调用

##### 7，内核数据结构

- 链表 : list_head 循环双向链表，它不是将数据结构塞入链表，而是将链表塞入数据结构内
- 队列 : kfifo
- 队列
- 映射 : 
  - hash 表
  - 二叉树
- 二叉树 :  rbtree

##### 8，中断

- 异常 : 是一种同步中断，处理方法与中断类似

- 又想中断处理程序运行的快，又想中断处理程序完成的工作量多，我们把中断处理切为两个部分，中断处理程序是上半部，能允许被推后执行的工作会被推迟到下半部去

- 内核接收一个中断后，它将依次调用在该中断线上注册的每一个处理程序，中断线共享的要求

  - request_irq() 的参数 flags 必须设置 IRQF_SHARED 标志
  - 对于每个注册的中断处理程序来说，dev 参数必须唯一
  - 中断处理程序必须能区分它的设备是否真的产生了中断

- 中断上下文，不可以睡眠

- 和上半部只能通过中断处理程序实现不同，下半部可以通过多种机制实现。这些用来实现下半部的机制分别由不同的接口和子系统组成

- 软中断保留给系统中对时间要求最严格以及最重要的下半部使用。目前，只有两个子系统 (网络和SCSI) 直接使用软中断。此外，内核定时器和 tasklet 都是建立在软中断上的

- 在工作队列和软中断/tasklet中做出选择非常容易。如果推后执行的任务需要睡眠，那么就选工作队列

  - 软中断 : ksoftirqd
  - 工作队列 : kworker
##### 9，同步

- 互斥体
- 信号量
- 读写锁
- 自旋锁
- 屏障

##### 10，计算机采用虚拟地址的原因

- 直接使用实模式 : 没有权限管理，任何程序可以访问任何物理内存
- 使用保护模式 : 使用段管理，实现了权限管理，但不方便内存的动态分配，而使用页式管理解决了动态分配

##### 11，VFS

- 超级块对象  

- 索引节点对象

- 目录项对象
  - 目录项状态 : 
    - 被使用
    - 未被使用
    - 负状态
  
- 文件对象

##### bio结构体 : 

	像RAID这样的驱动器，可以把单独的bio结构体分割到RAID阵列中的各个硬盘上，即RAID性能的来源

##### 12，I/O 调度程序

​		I/O 调度程序将块I/O请求挂起在请求队列中(reques_queue)，整个队列按扇区增长方向有序排列，为了优化寻址操作，内核既不会简单的按请求接收次序，也不会立即将其提交给磁盘，它会在提交前先执行名为合并与排序的预操作。

- Linus 电梯 : 虽然改善了等待时间，但任会导致请求饥饿
  - 如果队列中已存在一个对相邻磁盘扇区的请求，那么新请求将和这个已存在的请求合并为一个请求
  - 如果队列中存在一个驻留时间过长的请求，那么新请求将被插入队列尾部
  - 如果队列中存在以扇区方向为序存在合适位置则插入该位置，否则插入队尾
- 最终期限I/O调度程序 : 基于Linus电梯，改善了特别是读请求的饥饿现象
  - 每一个请求都有一个超时时间，默认读请求是500ms，写请求是5s。
  - 包含读请求队列，写请求队列，排序队列和派发队列四条队列
- 预测I/O调度程序 : 基于最终期限I/O调度程序，增加了预测启发能力
  - 等待6ms来等待其他按当前顺序的请求
  - 2.6.33后被删除
- 完全公正的排队I/O调度程序(CFQ) : 专为有工作负荷设计的 (默认)
  - 每个提交的I/O的进程都有自己的队列
  - 以时间片轮转调度队列
  - 预定的工作负荷是多媒体，保证音频播放器总能够及时从磁盘填满它的音频缓冲区
- 空操作的I/O调度程序 : 除了排序外，不用任何算法，专为随机访问设备设计，如SSD

##### 13，内存地址空间

- 平坦内存模式 : 平坦内存模式把全部系统内存表示为连续的地址空间。所有指令、数据和堆栈都包含在相同的地址空间中。通过称为线性地址（linear address）的特定地址访问每个内存位置
- 分段内存模式 : 分段内存模式把系统内存划分为独立段的组，通过位于段寄存器中的指针进行引用。每个段用于包含特定类型的数据。一个段用于包含指令码，另一个段用于包含数据元素，第三个段用于包含程序堆栈。段中的内存位置是通过逻辑地址定义的。逻辑地址由段地址（存放在段寄存器中）和偏移地址构成。处理器把逻辑地址转换为相应的线性地址位置以便访问内存的字节
- 实地址模式 : 如果程序使用实地址模式，那么所有段寄存器都指向零线性地址，并且不会被程序改动。所有指令码、数据元素、堆栈元素都是通过它们的线性地址直接访问的

##### 14，mm_struct，vm_area_struct

- mmap和mm_rb : 都表示该地址空间中的全部内存区域。前者是链表，后者是红黑树。内核利用mmap遍历元素，利用mm_rb搜索元素。mmap使用单独链表通过vm_next连接所有的内存区域对象，所有区域按地址增长方向排序。mm_rb使用红黑树连接所有内存区域对象，mm_rb指向红黑树根节点，vm_area_struct通过vm_rb参数连接到红黑树
- mm_struct是一个程序在内存中的执行摘要，它分为可执行文件代码段(text代码段)，可执行文件已初始化全局变量段(data数据段)，未初始化全局变量段(bss段)，堆，内存映射文件，栈，环境变量区等不同的部分，每个不同的部分都由vm_area_struct来表示。vm_area_struct中的vm_start表示区域的开始，vm_end表示区域的结束，vm_mm表示对应的mm_struct，它还包括访问控制权限等参数

##### 15，页缓存

- 写缓存
  - 不缓存
  - 写透缓存
  - 回写，linux 采用，标记为脏统一写回磁盘
- 缓存回收
  - 最近最少使用
  - 双链策略，基于LRU
    - 活跃链表 : 不会被换出
    - 非活跃链表 : 会被换出

##### 16，Buddy 算法

- 为了避免出现内存碎片，Linux内核中引入了伙伴系统算法(Buddy system)。把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。最大可以申请1024个连续页框，对应4MB大小的连续内存。每个页框块的第一个页框的物理地址是该块大小的整数倍

- 假设要申请一个256个页框的块，先从256个页框的链表中查找空闲块，如果没有，就去512个页框的链表中找，找到了则将页框块分为2个256个页框的块，一个分配给应用，另外一个移到256个页框的链表中
- Buddy算法牛逼就牛逼在运用了世界上任何正整数都可以由2^n的和组成。这也是Buddy算法管理空闲页表的本质 cat /proc/buddyinfo