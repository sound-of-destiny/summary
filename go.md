Go

- 特性
  - 自动垃圾回收
  - 更丰富的内置类型 : map 和 数组切片 slice
  - 函数多返回值 
  - 错误处理 : defer, panic, recover
  - 匿名函数和闭包 : f := func(x, y int) int { return x + y }
  - 类型和接口
  - 并发编程 : 在函数调用前使用关键字 go，CSP 通过 channel 通信
  - 反射
  - 语言交互性 : 调用 c 语言模块，Cgo
- go命令行工具的革命性之处在于彻底消除了工程文件的概念，完全用目录结构和包名来推导工程结构和构建顺序
- 支持多重赋值 i, j = j, i 
- 向channel写入数据通常会导致程序阻塞，直到有其他goroutine从这个channel中读取数据。如果channel之前没有写入数据，那么从channel中读取数据也会导致程序阻塞，直到channel中被写入数据为止
- go语言直接在语言级别支持select关键字，用于处理IO多路复用问题。select { case ch<- 0; case <- ch; default }
- Gosched() 让出goroutine时间片
- 同步锁 : sync.Mutex，sync.RWMutex
- tcp连接 : net.Dial("tcp", "127.0.0.1":10000)
- udp连接 : net.Dial("udp", "127.0.0.1:12345")
- icmp连接 : net.Dial("ip4:icmp", "www.baidu.com")
- go反射 : reflect.Valueof().Elem()
- 协程
  - 能够在单一的系统线程中模拟多个任务的并发执行
  - 在一个特定时间只有一个任务在运行，即并非真正的并发执行
  - 每个协程都有自己的堆栈和局部变量
- go 内存管理
  - Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的TCMalloc算法，全称Thread-Caching Malloc。核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理 : 每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争
  - Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理。申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小。
    - arena区域就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成8KB大小的页，一些页组合起来称为mspan
    - bitmap区域标识arena区域哪些地址保存了对象，并且用4bit标志位表示对象是否包含指针、GC标记信息。bitmap中一个byte大小的内存对应arena区域中4个指针大小（指针大小为 8B ）的内存，所以bitmap区域的大小是512GB/(4*8B)=16GB
    - spans区域`存放`mspan（也就是一些`arena`分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以spans区域的大小就是512GB/8KB*8B=512MB。除以8KB是计算arena区域的页数，而最后乘以8是计算spans区域所有指针的大小。创建mspan的时候，按页填充
  - 内存管理单元
    - mspan : Go中内存管理的基本单元，是由一片连续的8KB的页组成的大块内存。注意，这里的页和操作系统本身的页并不是一回事，它一般是操作系统页大小的几倍。一句话概括：mspan是一个包含起始地址、mspan规格、页的数量等内容的双端链表。每个mspan按照它自身的属性Size Class的大小分割成若干个object，每个object可存储一个对象。并且会使用一个位图来标记其尚未使用的object。属性Size Class决定object大小，而mspan只会分配给和object尺寸大小接近的对象，当然，对象的大小要小于object大小。Go1.9.2里`mspan`的`Size Class`共有67种，每种`mspan`分割的object大小是8*2n的倍数，这个是写死在代码里的。
  - 内存管理组件