java

- 反射 : Java 反射机制在程序**运行时**，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 **动态的获取信息** 以及 **动态调用对象的方法** 的功能称为 **java 的反射机制**
  - private 有什么用 : private想表达的不是“安全性”的意思，而是**面向对象的封装概念**，如不允许外部直接通过 new 来创建对象，那么构造方法必须是private
  - 优点 : **使程序更灵活、提高程序复用率**
  - 缺点 : **速度慢、使代码复杂、有副作用**
  - 使用反射 : 
    - Class.forName()、getClass() 和 XXX.class 来获取类对象
    - 然后通过 getMethods()、getFields() 等来获取 Method 数组和 Field 数组
    - 调用 invoke 方法来调用目标方法或者调用 set() 或 get() 方法来获取或设置 field 参数
- HashMap
  - 负载因子 loadFactor 为何是 0.75 : 小了空间利用率差，大了容易造成哈希冲突
  - put流程 :
    - 判断 Node 数组 table 是否为空，为空就进行 resize (Initializes or doubles table size) 操作
    - 判断 hash 值对应的 table 中的元素是否为空，为空调用 newNode (Create a regular (non-tree) node) 操作，生成一个常规 Node 节点
    - hash 值对应的 table 中的元素不为空，则
      - 判断是否存在原来的值
      - 利用 instanceof 判断是否为 TreeNode，如果是则调用 putTreeVal() 方法
      - 不是 TreeNode 则会循环直到到达链表尾生成新的节点 newNode()
      - 同时判断是否超过 TREEIFY_THRESHOLD 如果是则调用 treeifyBin (Replaces all linked nodes in bin at index for given hash) 来将链表转化为红黑树
      - 更换新值
    - 判断 size 是否超过 threshold 是则调用 resize (Initializes or doubles table size) 操作来双倍化 table
  - resize流程 : 首先计算 newCap 和 newThr，然后拆分红黑树或把链表根据高位 hash 值分为两条
    - 判断 oldCap 是否大于 0
    - 判断 oldThr 是否大于 0
    - 判断 newThr 是否等于 0
- ConcurrentHashMap
  - MIN_TREEIFY_CAPACITY = 64
  - 我们发现table数组是被volatile关键字修饰的，这就代表我们不需要担心table数组的线程可见性问题，也就没有必要再加锁来实现并发了
- java程序的初始化工作可以在许多不同的代码块中来完成，他们的执行顺序为 : 父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数
- 子类可以通过super关键字来显式地调用父类的构造函数，当父类没有提供无参构造函数时，子类的构造函数中必须显式地调用父类的构造函数
- java线程的6种状态
  - NEW : 初始，新创建了一个线程对象，但还没有调用start()方法
  - RUNNING/READY : 运行中/就绪，Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”
  - WAITING : 等待，进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）
  - TIMED_WAITING : 超时等待
  - BLOCKED : 阻塞，表示线程阻塞于锁
  - TERMINATED : 终止，表示该线程已经执行完毕
- java程序对类的使用方式分为两种
  - 主动使用(七种)
    - 创建类的实例，new
    - 访问某个类或接口的静态变量，或者对该静态变量赋值
    - 调用类的静态方法
    - 反射
    - 初始化一个类的子类
    - Java虚拟机启动时被标明为启动类的类，含有main方法
    - 动态语言的支持，了解
  - 被动使用
  - 所有的Java虚拟机实现必须在每个类或接口被Java程序“**首次主动使用**”时才初始化他们
- 对于静态字段来说，只有直接定义了该字段的类才会被初始化。
- 当一个类在初始化时，要求其父类全部都已经初始化
- 常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，因此不会触发定义常量的类的初始化你
- 即使在号称(几乎)不会发生停顿的CMS收集器中。枚举根节点时也是必须要停顿的
- 虚拟机利用称为OopMap的数据结构来得知有哪些地方存在着对象引用，在类加载完成时
- HotSpot没有为每条指令都生成OopMap，只在称为安全点的地方记录
- 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及CSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备卸载的功能，以保证元空间不会溢出
- 运行期间也可以将新的常量放入常量池中，这种特性被开发人员用的比较多的就是String类的intern()方法
- CMS (Concurrent Mark Sweep) : 
  - 初始标记  需要Stop The World
  - 并发标记
  - 重新标记  需要Stop The World
  - 并发清除
- G1
  - 分代整理 : 分代概念在G1中得到保留，他可以独立管理整个GC堆
  - 空间整合 : 与CMS的"标记-清除"算法不同，G1从整体上来看是基于"标记-整理"算法，在局部(两个"region"之间)上来看是基于"复制"算法的 
- 类加载
  - 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定 : 在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定)
  - 加载
    - 通过一个类的全限定名来获取定义此类的二进制字节流
    - 将这个字节流所代表的静态存储结构转化为元空间的运行时数据结构
    - 在内存中生成一个代表这个类的Class对象，作为元空间这个类的各种数据的访问入口
    - 开发人员可以通过自定义的类加载器去控制字节流的获取方式,即重写一个类加载器的loadClass()方法
    - 对于数组而言，数组本身不通过类加载器创建，它是由Java虚拟机直接创建的，但数组类的元素还是得依靠类加载器去创建
  - 验证
    - 文件格式验证
    - 元数据验证
    - 字节码验证
    - 符号引用验证
  - 准备
    - 正式为类变量分配内存并设置类变量初始值的阶段，类变量(被static修饰的变量)
  - 解析
    - 解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程
  - 初始化
    - 到了初始化阶段，才真正开始执行类中定义的Java程序代码
- 类加载器
  - 启动类加载器 : 负责将存放在<JAVA_HOME>\lib目录中的类库加载到虚拟机内存中
  - 扩展类加载器 : 负责加载<JAVA_HOME>\lib\ext目录中的类库
  - 应用类加载器 : 负责加载用户类路径上所指定的类库
  - 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，这里类加载器之间的父子关系一般不会以继承的关系来实现，而都是以组合关系来复用父加载器的代码
  - 双亲委派模型的工作过程是 : 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载
- 破坏双亲委派模型
  - 线程上下文类加载器
- java 异常处理
  - 如果在异常处理过程中，先捕获了基类，再捕获子类，那么捕获子类的代码块将永远不会被执行
- 多态 java : 同一个操作作用在不同的对象时，会有不同的语义和结果
  - 方法的重载 : 编译时多态，同一个类中有多个同名的方法，但这些方法有不同的参数
  - 方法的覆盖 : 运行时多态，子类可以覆盖父类的方法，因此同样的方法会在父类和子类中有着不同的表现形式
- 抽象类和接口有什么异同
  - 把类或类中的某些方法声明为abstract来表示类是一个抽象类，用interface来实现接口
  - 接口是实现(implements)，抽象类是继承(extends)，可以多实现但不能多继承
- 父类没有**无参**的构造函数，所以子类需要在自己的构造函数中显式调用父类的构造函数
- Spring 只帮我们管理单例模式 Bean 的**完整**生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期
- jdk spi
  - ServiceLoader.load(xxx.class)
  - META/service目录下
- RPC的原理和框架
  - RPC的程序包括5个部分 : **User <-> User-stub <-> RPCRuntime <-> Server-stub <-> Server**
  - user-stub 负责将调用的**接口、方法和参数**通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端的 ROCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端
  - RPC框架的核心技术点
    - 服务暴露 : 代码生成的方式对跨语言平台 RPC 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现
    - 远程代理对象 : 通过动态代理来实现
    - 通信
    - 序列化
- 零拷贝 java : transferTo()
  - 本来的流程 : 硬盘 >>DMA>> kernel buffer >>CPU>> user buffer >>CPU>> kernel socket buffer >>DMA>> NIC buffer
  - 使用 sendFile() 系统调用的流程 : 硬盘 >>DMA>> kernel buffer >>DMA>> NIC buffer，**数据未被拷贝到套接字缓冲区。取而代之的是，只有包含关于数据的位置和长度的信息的描述符被追加到了套接字缓冲区。DMA 引擎直接把数据从内核缓冲区传输到协议引擎，从而消除了剩下的最后一次 CPU 拷贝**
- 快速失败
  - 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception
  - 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历
  - 这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug
-  安全失败
  - 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历
  - 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception
  - 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的