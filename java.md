java

- 多态 : 接口的多种不同的实现方式即为多态。多态性在Object Pascal和C++中都是通过[虚函数](https://baike.baidu.com/item/虚函数/2912832)实现的
- 反射 : Java 反射机制在程序**运行时**，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 **动态的获取信息** 以及 **动态调用对象的方法** 的功能称为 **java 的反射机制**
- java程序的初始化工作可以在许多不同的代码块中来完成，他们的执行顺序为 : 父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数
- 子类可以通过super关键字来显式地调用父类的构造函数，当父类没有提供无参构造函数时，子类的构造函数中必须显式地调用父类的构造函数
- java线程的6种状态
  - NEW : 初始，新创建了一个线程对象，但还没有调用start()方法
  - RUNNING/READY : 运行中/就绪，Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”
  - WAITING : 等待，进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）
  - TIMED_WAITING : 超时等待
  - BLOCKED : 阻塞，表示线程阻塞于锁
  - TERMINATED : 终止，表示该线程已经执行完毕
- java程序对类的使用方式分为两种
  - 主动使用(七种)
    - 创建类的实例，new
    - 访问某个类或接口的静态变量，或者对该静态变量赋值
    - 调用类的静态方法
    - 反射
    - 初始化一个类的子类
    - Java虚拟机启动时被标明为启动类的类，含有main方法
    - 动态语言的支持，了解
  - 被动使用
  - 所有的Java虚拟机实现必须在每个类或接口被Java程序“**首次主动使用**”时才初始化他们
- 对于静态字段来说，只有直接定义了该字段的类才会被初始化。
- 当一个类在初始化时，要求其父类全部都已经初始化
- 常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，因此不会触发定义常量的类的初始化你
- 即使在号称(几乎)不会发生停顿的CMS收集器中。枚举根节点时也是必须要停顿的
- 虚拟机利用称为OopMap的数据结构来得知有哪些地方存在着对象引用，在类加载完成时
- HotSpot没有为每条指令都生成OopMap，只在称为安全点的地方记录
- 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及CSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备卸载的功能，以保证元空间不会溢出
- 运行期间也可以将新的常量放入常量池中，这种特性被开发人员用的比较多的就是String类的intern()方法
- CMS (Concurrent Mark Sweep) : 
  - 初始标记  需要Stop The World
  - 并发标记
  - 重新标记  需要Stop The World
  - 并发清除
- G1
  - 分代整理 : 分代概念在G1中得到保留，他可以独立管理整个GC堆
  - 空间整合 : 与CMS的"标记-清除"算法不同，G1从整体上来看是基于"标记-整理"算法，在局部(两个"region"之间)上来看是基于"复制"算法的 
- 类加载
  - 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定 : 在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定)
  - 加载
    - 通过一个类的全限定名来获取定义此类的二进制字节流
    - 将这个字节流所代表的静态存储结构转化为元空间的运行时数据结构
    - 在内存中生成一个代表这个类的Class对象，作为元空间这个类的各种数据的访问入口
    - 开发人员可以通过自定义的类加载器去控制字节流的获取方式,即重写一个类加载器的loadClass()方法
    - 对于数组而言，数组本身不通过类加载器创建，它是由Java虚拟机直接创建的，但数组类的元素还是得依靠类加载器去创建
  - 验证
    - 文件格式验证
    - 元数据验证
    - 字节码验证
    - 符号引用验证
  - 准备
    - 正式为类变量分配内存并设置类变量初始值的阶段，类变量(被static修饰的变量)
  - 解析
    - 解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程
  - 初始化
    - 到了初始化阶段，才真正开始执行类中定义的Java程序代码
- 类加载器
  - 启动类加载器 : 负责将存放在<JAVA_HOME>\lib目录中的类库加载到虚拟机内存中
  - 扩展类加载器 : 负责加载<JAVA_HOME>\lib\ext目录中的类库
  - 应用类加载器 : 负责加载用户类路径上所指定的类库
  - 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，这里类加载器之间的父子关系一般不会以继承的关系来实现，而都是以组合关系来复用父加载器的代码
  - 双亲委派模型的工作过程是 : 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载
- 破坏双亲委派模型
  - 线程上下文类加载器
- java异常处理
  - 如果在异常处理过程中，先捕获了基类，再捕获子类，那么捕获子类的代码块将永远不会被执行
- 多态 java : 同一个操作作用在不同的对象时，会有不同的语义和结果
  - 方法的重载 : 编译时多态，同一个类中有多个同名的方法，但这些方法有不同的参数
  - 方法的覆盖 : 运行时多态，子类可以覆盖父类的方法，因此同样的方法会在父类和子类中有着不同的表现形式
- 抽象类和接口有什么异同
  - 把类或类中的某些方法声明为abstract来表示类是一个抽象类，用interface来实现接口
  - 接口是实现(implements)，抽象类是继承(extends)，可以多实现但不能多继承
- 父类没有**无参**的构造函数，所以子类需要在自己的构造函数中显式调用父类的构造函数